import "./App.css";
import "bootstrap/dist/css/bootstrap.min.css";
import TopBar from "./components/TopBar";
import LoadingScreen from "./components/LoadingScreen";
import { useEffect, useState, type KeyboardEvent } from "react";
import WeatherCodeImage from "./components/WeatherCodeImage";
import CurrentWeather from "./components/CurrentWeather";
import HoursList from "./components/HoursList";
import WeatherHour from "./components/WeatherHour";
import shared from "./components/shared/shared.module.css";
import { useSpring, animated, Spring } from "react-spring";

// imgs
import sunrise from "./assets/sun-rise.jpg";
import night from "./assets/night.jpg";

const celciusFont = "Â°C";
interface WeatherState {
  temperature?: number;
  weatherCode?: number;
  time?: number;
}

// generated this helper func by ai
const formatTime = (
  dateString: string,
  timeZone: string,
  use24Hour: boolean,
) => {
  if (!dateString || !timeZone) return "";

  const date = new Date(dateString); // Create a Date object
  return new Intl.DateTimeFormat("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: !use24Hour,
    timeZone: timeZone,
  }).format(date);
};

// also generated by ai
function timeToMinutes(timeStr: string) {
  const [hours, minutes] = timeStr.split(":").map(Number);
  return hours * 60 + minutes;
}

const App = () => {
  const [isLoading, setLoading] = useState(false);
  const [currentWeather, setCurrentWeather] = useState<WeatherState>({});
  const [hourlyWeather, setHourlyWeather] = useState<WeatherState[]>([]);
  const [location, setLocation] = useState({
    latitude: null,
    longitude: null,
    countryName: null,
    cityName: null,
  });
  const [backgroundImg, setBackgroundImg] = useState(sunrise);

  const fetchWeather = async (latitude: string, longitude: string) => {
    const apiEndpoint = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m,weather_code&current=temperature_2m,weather_code&timezone=auto&forecast_days=1`;
    try {
      const data = await fetch(apiEndpoint);
      if (!data.ok)
        return new Error(
          `open meteo failed to fetch from coords : (${latitude}, ${longitude})`,
        );
      const info = await data.json();
      return info;
    } catch (err) {
      console.log(err);
    }
  };

  const fetchCurrentLocation = async () => {
    const apiEndpoint = "https://geoapi.info/api/geo";
    try {
      const data = await fetch(apiEndpoint);

      if (!data.ok) throw new Error("current location response is invalid");
      const info = await data.json();
      return info.location;
    } catch (err) {
      console.log(err);
    }
  };

  const fetchLocationFromCityName = async (cityName: string) => {
    const apiEndpoint = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(cityName)}`;
    try {
      const data = await fetch(apiEndpoint);
      if (!data.ok) throw new Error("input location response is invalid");
      const info = await data.json();
      return info;
    } catch (err) {
      console.log(err);
    }
  };

  // events //
  const onSearchInputEntered = (ev: KeyboardEvent<HTMLInputElement>, failed: () => void) => {
    const inputValue = ev.currentTarget.value;
    const cityName = inputValue.trim();
    if (cityName.length <= 2) return;
    console.log("querying for: " + cityName);
    setLoading(true);
    fetchLocationFromCityName(cityName)
      .then((info) => {
        if (!info.results) throw new Error(`No results of ${cityName}`);
        return info.results;
      })
      .then((results) => {
        const bestResult = results[0];
        const lat = bestResult.latitude;
        const long = bestResult.longitude;
        const cityName = bestResult.name;
        const countryName = bestResult.country;
        setLocation({
          latitude: lat,
          longitude: long,
          cityName: cityName,
          countryName: countryName,
        });
      })
      .catch((err) => {
        setLoading(false);
        console.log(err);
        failed()
      });
  };

  // springs

  const config = { friction: 8, tension: 100, mass: 0.5 };

  const hoursListPopAnim = useSpring({
    marginBottom: isLoading ? "-100px" : "0px",
    config: config,
  });

  const currentWeatherPopAnim = useSpring({
    marginLeft: isLoading ? "-100px" : "0px",
    config: config,
  });
  // effects //

  // setting the states after new location has been entered
  useEffect(() => {
    console.log("#~~~~~~~~~~\n", location, "\n#~~~~~~~~~~\n");
    const lat = location.latitude as unknown as string;
    const long = location.longitude as unknown as string;
    if (!lat || !long) return console.log("latitude and longitude are null.");
    fetchWeather(lat, long).then((info) => {
      const timeZone = info.timezone;
      console.log(info);
      // current weather
      const currentWeather = info.current;
      const currentTemp = currentWeather.temperature_2m;
      const weatherCode = currentWeather.weather_code;
      const currentTime = currentWeather.time;
      setCurrentWeather({
        temperature: currentTemp,
        weatherCode: weatherCode,
      });

      // setting the background image to time (paris => day, aurora bourialis => night)
      const formattedCurrentTime = formatTime(currentTime, timeZone, true);
      const currentTimeToMinutes = timeToMinutes(formattedCurrentTime);
      const dayBegins = timeToMinutes("06:00");
      const dayEnds = timeToMinutes("18:00");
      if (currentTimeToMinutes > dayBegins && currentTimeToMinutes < dayEnds) {
        // day
        setBackgroundImg(sunrise);
        console.log("day " + formattedCurrentTime);
      } else {
        setBackgroundImg(night);
        console.log("night");
      }

      // hourly temp
      const hourlyWeather = info.hourly;
      const hourlyTime = hourlyWeather.time;
      const hourlyTemp = hourlyWeather.temperature_2m;
      const hourlyWeatherCode = hourlyWeather.weather_code;
      const newHourlyWeather = hourlyTime.map((hour: any, i: number) => ({
        weatherCode: hourlyWeatherCode[i],
        time: formatTime(hour, timeZone, false),
        temperature: hourlyTemp[i],
      }));

      setHourlyWeather(newHourlyWeather);

      setLoading(false);
    });
  }, [location]);

  // get city closest to client
  useEffect(() => {
    setLoading(true);
    fetchCurrentLocation().then((location) => {
      const coords = location.coordinates;
      const lat = coords.latitude;
      const long = coords.longitude;
      const countryName = location.countryName;
      const cityName = location.city;
      setLocation({
        latitude: lat,
        longitude: long,
        countryName: countryName,
        cityName: cityName,
      });
    });
  }, []);

  // component //
  return (
    <div
      style={{
        backgroundImage: `url(${backgroundImg})`,
        backgroundSize: "cover",
        backgroundPosition: "center",
        height: "100vh",
        width: "100vw",
      }}
      aria-label="background image">
      <div className="layout">
        <TopBar onSearchEnter={onSearchInputEntered} />
        {isLoading ? (
          <LoadingScreen />
        ) : (
          <div
            className={shared.layout}
            style={{
              justifyContent: "space-between",
            }}>
            <CurrentWeather
              color={backgroundImg == sunrise ? "black" : "rgb(220, 229, 235)"}>
              <animated.div style={currentWeatherPopAnim}>
                <h2 className="country-name">
                  {location.cityName + ", " + location.countryName}
                </h2>
                <div
                  style={{
                    display: "flex",
                    flexDirection: "row",
                  }}>
                  <h1 className="current-temp">{currentWeather.temperature}</h1>
                  <span className="celcius">{celciusFont}</span>
                </div>
                <WeatherCodeImage weatherCode={currentWeather.weatherCode} />
              </animated.div>
            </CurrentWeather>
            <HoursList>
              {hourlyWeather.map((item, i) => {
                return (
                  <WeatherHour key={i}>
                    <animated.div
                      style={{
                        display: "flex",
                        flexDirection: "column",
                        justifyContent: "space-between",
                        height: "100%",
                        ...hoursListPopAnim,
                      }}>
                      <div aria-label="time">
                        <h3 className="time">{item.time}</h3>
                      </div>
                      <div>
                        <h2 className="weatherCode">
                          <WeatherCodeImage
                            weatherCode={item.weatherCode}
                            hideMessage={true}
                          />
                        </h2>
                        <h3 className="temperature">
                          {item.temperature + celciusFont}
                        </h3>
                      </div>
                    </animated.div>
                  </WeatherHour>
                );
              })}
            </HoursList>
          </div>
        )}
      </div>
    </div>
  );
};

export default App;
